---
title: 代码随想录一刷笔记_哈希表
tags: 
  - Notes
  - leetCode
  - data structure
  - algorithm
  - C++
categories: 
  - [代码随想录]
date: 2024-09-08 20:20:00

---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

## 哈希表理论基础

哈希表用于快速判断一个元素是否出现在集合里，是一种用**空间换时间**的方法。

当数据通过函数映射到同一位置时，会出现**哈希碰撞**的现象，一般有线性探测法和拉链法两种办法应对。

数组、set、map三种数据结构的适用情况：

- 数组：适用于数据量小，数据集中的情况
- set：适用于数据量大、数据离散的情况
- map：适用于数据量大，需要存储键值对的情况

## 有效的字母异位词（242）

这一道题只定义一个数组即可解决。

①遍历两串字母，将遇到的字母填入对应的哈希表序列

②遍历数组，查找是否有异位的字母。

- tips：相关题目找到字符串中所有字母异位词（438）中，需要考虑避免下标越界的问题。（似乎本题还可以使用滑动窗口的思想）

## 两个数组的交集（349）

这一题主要是科普了set这类数据结构 & 范围for循环的语法。

- set

  - 适合使用set的情况：数据很多、数值很分散的情况。（**PS**：如果需求对重复数据有特别要求需慎重考虑 unordered_set！）

  - 用set这种数据结构存储数据可以实现去重的效果。

    ```c++
    // 定义一个 unordered_set 类型数据结构
    unordered_set<int> result_set;
    
    // 将num1容器中的数据存入 nums_set 中时，能够实现去重 & 排序 功能
    unordered_set<int> nums_set(num1.begin(), num1.end());
    ```

  

- 范围for循环

  - 提供了一种简洁的方式遍历容器（数组，vector，list）中的元素

    ```c++
    for (declaration: range) {
        ....
    }
    ```



## 快乐数（202）

由于不知道输入的数据大小，所以如果使用数组的话需要留很大的冗余。故，这类题目更适合使用set这种数据结构回答。

set提供了一个成员函数find()，用于在容器中查找特定的元素，返回值取决于查找操作的结果：

- 如果找到了指定的元素，find()函数会返回一个指向该元素的迭代器；

- 如果没有找到指定的元素，find()函数会返回容器的end()迭代器。

  - end()迭代器是一个哨兵值，其不指向容器中的任何元素，而是作为一个标记，表示容器的末尾。

  - 在遍历容器时，通常使用end()迭代器来表示何时停止遍历。

    ```c++
    // 判断计算得到的数据是否已经出现过
    set.find(sum) != set.end();
    ```



## 两数之和（1）

这一题的需求是需要存储考虑存储数组index以及数据，所以适用map这种数据结构。

- auto关键字：

  auto是在c++11标准中引入的，用于自动推导变量的类型。

  ```c++
  // 在这一行代码中，iter的类型应该是 std::map<Key, T>::iterator
  // 在这一行代码中，map.find() 方法寻找的是键为 target - nums[i] 的元素。（关键字是唯一的！）
  auto iter = map.find(target - nums[i]); 
  ```



- unordered_map

  - 访问map中value的值

    ```c++
    // 在这里，iter表示指向map的一个有效元素
    // iter->first 表示访问迭代器iter所指向元素的键部分
    // iter->second 表示访问迭代器iter所指向的元素的值部分
    auto iter = map.find(target - nums[i]); 
    if(iter != map.end()) {
    	return {iter->second, i};
    }
    ```

    

  - insert方法

  ```c++
  // insert方法
  // pair<int, int>(a, b) 创建了一个临时的 std::pair 对象
  // insert需要一个pair类型的参数，而不是两个单独的值
  map.insert(pair<int, int>(a + b, c));
  ```



## 四数相加Ⅱ（454）

这一题如果使用暴力解法的话是需要四层for循环，时间复杂度是O(n^4)。故，我们需要对其进行降重操作（采用nums1和nums2，nums3和nums4两两相加的方式）。

接下来的问题是采用哪一种数据结构：

- 首先在定义里，数组中的值的大小达到了2^28，存在数据量过大以及数据过于分散的问题，故排除使用数组；
- 然后我们需要计算所有和为0的情况，涉及重复数据的计算，所以需要额外的一个变量来记录有几个重复的值。

故，这一题使用**map**更合理一些，一个变量用来存储两两相加的结果，另一个变量用来存储这个结果出现的次数。

## 赎金信（383）

这一题只涉及26个字母，数据量不大，但是涉及到对重复数据的计数，故，可以使用数组和map两种数据结构。

```c++
// 范围for循环中的问题
// 在这一题中，遍历的是String类型的字符串，使用char类型进行遍历后，在循环体中c赋值得到的是magazine中每一个的字符。
	string magazine='xxx';
	for (char c: magazine)
    {
        // ....
        // 进行 c-'a'操作时，会直接转换为asall码计算。
        num[c - 'a']++;
    }
```

