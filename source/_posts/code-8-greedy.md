---
title: 代码随想录一刷笔记_贪心算法
tags: 
  - Notes
  - LeetCode
  - Data structure
  - Algorithm
  - C++
categories: 
  - [LeetCode, 代码随想录]
date: 2024-11-11 20:20:00

---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

## 贪心算法理论基础

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

第一个难点是如何判断该使用贪心算法了，需要 手推/特殊值/举反例 的方法。

#### 贪心算法的解题步骤：

找到局部最优是什么，然后推导出全局最优。

## 455 分发饼干

这一题的优化技巧在于，饼干分配掉之后是不会再使用了，所以可以使用一个指针指向最大尺寸的饼干，分配掉之后向前递减即可。省去了一重for循环 & 判定当前饼干是否分配的空间。

## 376 摆动序列

#### 回溯

这一题先是使用了回溯的方法解决，虽然进行了一定的剪枝操作，但还是被一个很长的测试样例卡住了。事实证明，回溯是一种暴力算法，效率不是很高。

#### 贪心算法

例如 [33,53,12,64,50,41,45,21,97,35,47,92,39,0] 这一个测试样例，可以画出这样的图

<img src="https://pic-poivre.oss-cn-hangzhou.aliyuncs.com/pics/2305adb002cca4053ce43f861db53f4.jpg" alt="2305adb002cca4053ce43f861db53f4" style="width:50%;" />

可以得到的最长的摆动序列就是荧光笔标注的地方。记录每一个波峰和波谷，去除其他的元素，想起来挺有道理的，但是数学证明略（其实是不会）。。。。

用一个变量记录下一个应该收录的元素应该是在波峰还是波谷，然后记录最长的长度即可。

PS. 这个是我一开始的解法版本，错误只出在一个逆天（特别长）的测试用例上， 找这个问题找了许久。

```c++
if (nums.size() == 1) return 1;
int flag = 0;
int lastNum = nums[0];
for (int i = 1; i < nums.size(); i++) {
    if (nums[i] == lastNum) continue;
    else if (nums[i] > lastNum && flag < 0) continue;
    else if (nums[i] < lastNum && flag > 0) continue;
    else {
        result.push_back(nums[i]);
        if (nums[i] > lastNum) flag = -1;
        else flag = 1;
        lastNum = nums[i];
    }
}
```

想法是这样的，由于我要找的是有几个上升序列和下降序列，所以我只要记录这条趋势里的一个数字即可，然后就造成了一种类似抖动幅度变小的结果。

<img src="https://pic-poivre.oss-cn-hangzhou.aliyuncs.com/pics/381a9a7ddffc8db38fdaa6d20998f1e.jpg" alt="381a9a7ddffc8db38fdaa6d20998f1e" style="width:50%;" />

后来改成了和前一个数字进行比较

```c++
for (int i = 1; i < nums.size(); i++) {
    if (nums[i] > nums[i - 1] && flag != 1) {  // 如果当前元素比前一个大且趋势不是上升
        length++;
        flag = 1;  // 更新趋势为上升
    } else if (nums[i] < nums[i - 1] && flag != -1) {  // 如果当前元素比前一个小且趋势不是下降
        length++;
        flag = -1;  // 更新趋势为下降
    }
    // 如果nums[i] == nums[i-1]，什么都不做
}
```

虽然说仍然记录的不是波峰和波谷的那几个数据，但是是记录了有几条上升/下降趋势。

PS.. 题解的版本是根据当前数值和前一个&后一个的差值判断是不是在波峰/波谷上。

PS... 遇到问题还是得数形结合，干瞪眼了好久没想到好的办法。。。。

## 53 最大子序和

#### 尝试

尝试作答，但是被逆天的测试样例击败了（好多涉及“0”的问题，包括数组中本就有0，以及连续的数据中相加和为0等）。

##### 1.ed

想法是这样的， 先标记数组中从开头（赋值给startIndex）数和从结尾（赋值为endIndex）数第一个为正数的数，然后对这一段截取的序列进行如下操作：

1. 分别从开头和结尾进行遍历，如果当前的数（为正数）和后/前一个数的和为正数，则退出循环，认为当前的这一段就是最大的子数组
2. 进行求和。

##### 2.ed

在遇到可能出现连续的多个负数，这几个负数的和的绝对值比相邻的正数大的情况。所以我声明了一个新的向量path，将相邻的数据求和进行后置入path中。

但是，在测试过程中遇到了比如`[2,-1,-1,2,0,-3,3]`、`[3,-3,2,-3]`的逆天数据，因为首尾指向数据和相邻的和为0的问题，所以其最大子数组和为单个数字。

##### 3.ed

尝试打了一堆补丁，但总会冒出些新样例出来。。。。麻了。。。。

```c++
if (startNum > num) num = startNum;
if (endNum > num) num = endNum;
if (startIndex < endIndex) {
    if(startIndex >= 0) {
        if (path[startIndex] > num ) num = path[startIndex];
    }
    if (endIndex < path.size())
        if (path[endIndex] > num) num = path[endIndex];
}
```

#### 解法

##### 暴力解法 -> 两层for循环

题解第一个给出的是两层for循环，不过现在的测试样例里面塞进去了逆天数据，过不了了。

##### 贪心算法

看了题解之后，我明显意识到把简单问题复杂化了，只需遍历一遍数组，当总和在变大时累加，当总和开始变小时重置总和重新计算。。。。

服了。。。

fin.

## 122 买卖股票的最佳时机Ⅱ

这一题的前提条件是肯定是赚的（操盘手是个炒股糕手！📈）

如果要赚钱的话，肯定是不在同一天进行买入/卖出的操作。

可以把整个的收入分为好几段，一次买入+卖出记为一次操作，有两个情况：

- 买入时
  - 如果当天股价和后一天的股价相同，是否要买（如何去重）？
    - 不要买！因为买第二天的股即可，这里不存在利息的问题。

- 卖出时
  - 如果后一天的股价比当天股价要高？
    - 如果高的话，等一天再卖

#### PS

题解给出的答案更为简单，只需要遍历一遍数组，然后计算出递增的情况下的涨幅即可。不需要声明额外的变量，节约了空间。

## 55 跳跃游戏

#### 递归

看到这题，试用了一下递归方法，从可以跨越的最大步数向前递归，可以实现，但是又又又又遇到了逆天测试🤣。

递归部分的代码如下：

```c++
bool travelsal(vector<int>& nums, int startIndex) {
    if (startIndex + nums[startIndex] >= nums.size() - 1) return true;

    int steps = nums[startIndex];
    for (int i = steps; i > 0; i--) {
        bool flag = travelsal(nums, startIndex + i);
        if (flag) return true;
    }
    return false;
}
```

#### 贪心

题解将跳几步这个离散的问题化为可以跳跃的范围，遍历一遍数组，判定跳跃的范围能否到终点。

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

与解相比使用了三元运算符，打败了100%的人👍

```c++
bool canJump(vector<int>& nums) {
    int leap = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (leap >= nums.size() - 1) return true;
        if (i > leap) return false;
        leap = i + nums[i] > leap ? i + nums[i] : leap;
    }
    return false;
}
```

欸，确实想不到。。。。

## 56 跳跃游戏Ⅱ

#### 回溯

不出意外就又是出意外了

又因为某个逆天测试超时了😂

#### 贪心

- 我的解法是定义一个数组，记录当前到达这个位置的最短步数，然后找到能够到达数组结尾的最短步数。

- 解答的方法更进一步，通过记录`当前覆盖最远距离下标`，`走的最大步数`，`下一步覆盖最远距离下标`三个变量查找最小步数。

  在每次的覆盖范围内（除去已经遍历的值外），找到能够覆盖最远覆盖范围的量。

  - 优化版本
    - 因为题目里明确表示给出的数据是能跳跃到终点的，所以可以只寻找最远覆盖范围到`nums.size() - 2`的位置。
    - 在遍历到`nums.size() - 2`的位置的时候，肯定会在这个位置或者之前肯定有一步`ans++`操作。


## 1005 K次取反后最大化的数组和

本题还是挺好想的，先把所有负数取反，然后就是对操作后数组中的最小值进行一个操作。

