---
title: 21天学习c++_part2笔记 
tags: 
  - Notes
  - c++
categories: 
  - [Tutorials, Book]
date: 2024-12-05 20:20:00
---

我要成为c++糕手！第二部分--c++面向对象编程基础

<!-- more -->

## Chapter9 类和对象

涉及的运算符：句点运算符（.），指针运算符（->），作用域解析运算符（::）

如果有一个指向对象的指针，则使用指针运算符；如果栈中实例化了一个对象，并将其存储到了一个局部变量中，则使用句点运算符。

#### 构造函数

与类同名且不返回任何值，在创建对象时被调用，用于初始化类成员变量。

**默认构造函数**：在**不提供参数**的情况下调用的构造函数。如果在没有提供默认构造函数，编译器将会自动创建一个，并且自动创建成员属性（会赋一些随机的垃圾值）。

**重载构造函数**：

构造函数也是**可以重载**的。如果声明中只给出了**重载构造函数**而没有给出默认构造函数的话，创建对象时编译器不会自动创建默认构造函数，而是必须调用这个重载构造函数，也就是必须给出参数值，否则会报错滴。

btw，如果构造函数中给的参数都给出了默认值，那么这个函数仍然是**默认构造函数**，实例化对象时可以不给出参数。

**包含初始化列表的构造函数:**

直接将参数值赋给声明对象中对应的变量

```c++
human(string humansName = "adam", int humansAge = 25) : name(humansName), age(humansAge)
```

**转换构造函数？**（没看懂9.3）

#### 析构函数

在对象销毁时自动被调用：①对象不在作用域时（如进程结束）；②对象通过delete被删除时。

btw，如果没有声明析构函数，编译器将创建一个伪（dummy）析构函数并调用。

##### 浅拷贝（shallow copy）

当一个类中包含指针成员时，复制这个类的对象时（例如作为在一个函数中被做为形参调用），会复制这个类的指针成员，而没有复制这个指针指向的内存，导致两个指针指向了同一块动态分配的内存。在销毁一个对象时，会释放这个内存块，而导致另一个指针指向内容无效。

##### 深拷贝（deep copy）

使用**复制构造函数**解决浅拷贝存在的问题（），复制指针的同时把指针指向另一块新的内存地址。这样多次调用析构函数销毁对象时就不是销毁同一地址的内容了。

```c++
// 复制构造函数
MyBuffer::MyBuffer(const MyBuffer& copySource) {
	// ....
}
// 移动构造函数
// 移动“临时资源”，避免复制构造函数带来的性能消耗
MyBuffer::MyBuffer(MyBuffer&& source) {
    // ....
}
```

#### this指针

在类中，this包含当前对象的地址，但是大多数情况this的使用都是可选的。

#### 声明友元

使用关键字friend，可以让外部的类和函数访问私有的数据成员和方法。

#### union

特殊的类，每次只有一个非静态数据成员处于活动状态。

与struct相似，union成员**默认是公有的**，但是是**不能继承**的。

```c++
union UnionName
{
    Type1 member1;
    Type2 member2;
    ...
    TypeN memberN;
}
UnionName unionObject;
unionObject.member2 = value;
```

