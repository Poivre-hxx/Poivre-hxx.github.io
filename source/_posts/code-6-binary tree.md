---
title: 代码随想录一刷笔记_二叉树
tags: 
  - Notes
  - LeetCode
  - Data structure
  - Algorithm
  - C++
categories: 
  - [LeetCode, 代码随想录]
date: 2024-09-20 20:20:00

---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

## 二叉树理论基础

###### 二叉树的遍历方式

- 深度优先遍历 => 栈
  - 前序遍历
  - 中序遍历
  - 后序遍历
- 广度优先遍历 => 队列
  - 层次遍历

二叉树的定义

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x): val(x), left(NULL), right(NULL) {} // 构造函数，初始化对象
}
```



## 二叉树的前中后序遍历

使用非迭代方法遍历二叉树，前序遍历和中序遍历的过程有一定的区别，**这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！**

###### 中序遍历（非迭代方法）

在解决中序遍历的非迭代方法时，while循环的判定条件为：

```c++
 while (!s.empty() || cur != nullptr){}
```



例如[1,null,2,3]这个例子，当把根节点的数据1弹出后，此时栈为空，cur指向数值为2的节点，所以判定条件需要同时考虑栈和指针是否为空。

###### 后序遍历（非迭代方法）

由于直接实现后序遍历似乎是不行的，所以在这里可以采取逆向思维！（；´д｀）ゞ

后序遍历要实现的是左右中遍历二叉树，反过来的话就是中右左遍历。所以在这里采取了先进行中右左遍历，然后将结果数组翻转的做法。(⊙﹏⊙)

###### 二叉树的统一迭代法

由于使用不同的遍历方法时，会存在访问节点和处理节点时间不一致的情况。故，可以采取将处理的节点放入栈的同时进行标记的方法！也就是在节点放入栈的同时放入一个空指针作为标记！

## 二叉树的层序遍历

###### 二叉树的层序遍历（102）

- 非递归方法

  tips: 遍历每一层的节点时，需要遍历队列中的现有元素。这里存在一个问题，遍历过程中，会将队列中的元素弹出，这样一来，队列的长度会发生变化。故，for循环的条件应为遍历前的队列长度（提前赋值的固定值）。

  ```c++
  // 遍历当前队列q中的节点
  int size = q.size();
  ....
  // 循环条件中的size需要为固定值！
  for (int i = 0; i < size; i++){....}
  ```



- 递归方法

  层序遍历的递归方法的函数如下：

  ```c++
  void order(TreeNode *cur, vector<vector<int>> &result, int depth)
  {
      if (cur == nullptr) return;
      // 深度是从0开始计数的，所以每到遍历至新的一层时，都会添加一个新的内部向量来存储当前层节点的值。
      // 使用这样的技巧，result的层数和深度值是匹配的。
      if (result.size() == depth) result.push_back(vector<int>());
      result[depth].push_back(cur->val);
      order(cur->left, result, depth + 1);
      order(cur->right, result, depth + 1);
  }
  ```

###### 二叉树的最小深度（111）

- 递归方法：需要在返回值里额外加一层判断，避免根节点一侧全为空的情况。

  ```c++
  return min(left, right) < 1 ? max(left, right) + 1: min(left, right) + 1;
  ```



- 非递归方法：最早遍历到的没有子树的节点就是最浅的深度所在的位置！

