---
title: 代码随想录一刷笔记_动态规划（下）
tags: 
  - Notes
  - LeetCode
  - Data structure
  - Algorithm
  - C++
categories: 
  - [LeetCode, 代码随想录]
date: 2024-12-09 20:20:00

---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

## 198 打家劫舍

因为之前做了一周的背包问题，所以现在看到题目的第一反应就是，这是背包😖😖....

实际上这一题并不满足背包的条件，背包需要满足容量是固定的，但是这一题是让我求最大的容量，根据题设，这是一个小于40000的正整数....

## 213 打家劫舍Ⅱ

我的想法，本题和上一题的区别在于数组由线性的变成了环状的，所以我加了一个布尔类型的数组用于判断当前的最大值里有没有包含首位数字，然后最后进行一个判断。但是在`[2,1,2,6,1,8,10,10]`这个样例里面没有通过。

```c++
// 处理代码段
if (nums.size() >= 3) {
    int delta1 = dp[nums.size() - 2] + nums[nums.size() - 1];
    int delta2 = dp[nums.size() - 3] + nums[nums.size() - 1];
    if (jud[nums.size() - 2]) delta1 -= min(nums[0], nums[nums.size() - 1]);
    if (jud[nums.size() - 3]) delta2 -= min(nums[0], nums[nums.size() - 1]);
    dp[nums.size()] = max(delta1, delta2);
}
```

#### 题解

看了题解，我是想把这一部分在一个循环里实现，搞复杂了，实际上只要遍历两次dp数组（分别包含首元素和尾元素），然后取最大值即可。。。。

数组环的三种情况：

1. 情况一：考虑不包含首尾元素
2. 情况二：考虑包含首元素，不包含尾元素
3. 情况三：考虑包含尾元素，不包含首元素

这里的情况一是包含在二和三里的，所以只需要遍历两遍取极大值即可。

PS：网友抚平了我提交10多次没有ac的痛苦，笑死了。

<img src="https://pic-poivre.oss-cn-hangzhou.aliyuncs.com/pics/image-20241210145220476.png" alt="image-20241210145220476" style="width:80%;" />

## 337 打家劫舍Ⅲ

第一个想法是，遍历二叉树成一个用前/中/后序排序的数组，然后根据这个数组进行下一步操作，但是演算了一番，似乎不太行得通。

于是乎，就有了第二个想法，使用层序遍历，遍历二叉树成一个二维向量组呢？好像也不太行，只能解决根节点这一层和第二、三层的关系，后面的对应关系就不好找了。

好像还是得在遍历的过程中完成打劫（bushi）

#### 记忆化递归

可以料到，如果使用递归的话大概率是会在一些样例上超时的，所以得要采取一点剪枝策略。

这里就引入了**记忆化递归**的方法。

使用一个map把计算过的结果保存一下，当重复遍历到一个节点时，可以直接复用结果，避免了重复遍历。

#### dp

卡哥定义这里的dp方法为树形dp（亦称为“树形贪心”），但还是逃不出dp五部曲的分析范围！

1. 确定dp数组以及下标的含义

   这里的dp数组容量为2，表示当前偷 & 不偷。

2. 确定递推公式

   数据存储在二叉树中，所以是要在遍历二叉树的过程中进行动规的！

   对当前节点`root`（dp[0]表示不偷，dp[1]表示偷）：

   - 如果不偷这个节点

     ```c++
     int val1 = max(left[0], left[1]) + max(right[0], right[1]);
     ```

     

   - 如果偷这个节点

     ```c++
     int val2 = root->val + dp[0] + dp[1];
     ```

   显然，在计算`root`节点可以偷到的最大金额时，需要知道`root`的两个孩子节点的情况！故，这里需要采用后序遍历的方法递归二叉树！

3. 递归函数如何初始化

   因为是使用后序遍历，所以只需在遍历到二叉树底部时初始化大小为0，容量为2的数组即可。

4. 确定遍历顺序

   由上述可得，使用后序遍历二叉树的方法！

至此，打家劫舍完结力*★,°*:.☆(￣▽￣)/$:*.°★* 。

## 121 买卖股票的最佳时机

试了下双重循环，超时咯！

#### 贪心

简化成了单重循环，记录遍历到当前下标前的所有数值的最小值，然后进行一个比较。

#### dp

第一时间没想到怎么做👉👈

看了下答案，哦，需要使用二维数组啊。然后dp数组的长度就是买卖股票天数的长度，原谅我看到天数定义小于等于10^5的时候不想往这方面考虑了👉👈👉👈

1. 数组下标及其含义

   `dp[i][0]`表示当天持有股票所得最多现金（是个负数，越大越好）

   `dp[i][1]`表示当天不持有股票所得最多现金（是个正数，越大越好）

2. 确定递推公式

   - 对于持有股票

     ```c++
     dp[i][0] = max(-prices[i], dp[i - 1][0]);
     ```

     

   - 对于不持有股票

     ```c++
     dp[i][i] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
     ```

3. 如何初始化

   其他都初始化为0，但是我们需要单独考虑一下第一天的情况（因为第一天没有前一天，比较特殊）。

## 122买卖股票的最佳时机Ⅱ

#### 贪心

简单回顾一下使用贪心的做法，遍历整个数组，当当天的股价大于前一天的股价时，买入前一天的股票并在当天卖出（实际上是不可能的），达到局部最优的目的。

#### dp

与上题类似，还是分为买/不买的二维数组。

1. 数组下标及其含义

2. 递推公式

   - 对于买入股票（最多只能持有一股，所以在买入的时候得卖掉）

     考虑当天买入新股票和前些天买入新股票谁亏的少？
   
     ```c++
     dp[i][0] = max(-prices[i] + dp[i - 1][1], dp[i - 1][0]);
     ```

     - 因为可以多次购买，所以需要考虑前面的收益有没有算进去的情况。只能同时购买一股，所以前一天不买入新股票的情况就是当天操作前的最佳收益，这样就算上了之前的操盘（凌乱的理解）。

   - 对于不买入股票
   
     考虑当天卖出股票和前些天卖出股票谁赚的多？

     ```c++
     dp[i][1] = max(prices[i] + dp[i - 1][0], dp[i - 1][1]);
     ```
   
     

## 123 买卖股票的最佳时机Ⅲ

#### 贪心（感觉应该是贪心？）

不难发现，可以把股价分成n个递增序列，然后我们要将他们合成两个差值是最大的，再求和。（不好实现）

聪明的claude给出了一个新思路。

- 对于每一天，计算
  - 在这一天之前完成一次交易能获得的最大利润
  - 在这一天之后完成一次交易能获得的最大利润
- 在所有可能的“分割点”中，找到左右两遍利润之和最大的情况

粗浅的理解一下，分割两边，是因为防止出现重复购买的情况！tql！我的超人claude老师！好大的脑洞！

#### dp

看了视频后，大彻大悟了属于是，卡哥牛逼！~

按照dp五部曲捋一下这一题。

1. dp数组以及下标表示的含义

   这里的买卖股票规矩是至多买两次。将dp数组分为五行，分别表示`没有操作过`、`第一次持有（包含当天买入 & 前一天买入）`、`第一次不持有（卖出力）`、`第二次持有`、`第二次不持有`。

2. 递推公式

   按五种情况分别描述：

   - 没有操作过：畏惧炒股市场，所以一直是0(bushi)

   - 第一次持有，保留最便宜的一支股票

     ```c++
     dp[1][i] = max(dp[0][i - 1] - prices[i], dp[1][i - 1]);
     ```

   - 第一次不持有，保留最赚的一次买卖经历

     ```c++c++
     dp[2][i] = max(dp[1][i - 1] + prices[i], dp[2][i - 1]);
     ```

     

   - 第二次持有，在第一次的基础上操作

     ```c++
     dp[3][i] = max(dp[2][i - 1] - prices[i], dp[3][i - 1]);
     ```

     

   - 第二次不持有，在第二次持有的基础上赚最多

     ```c++
     dp[4][i] = max(dp[3][i - 1] + prices[i], dp[4][i - 1]);
     ```

     

3. 初始化

   理解的方法：虽然说不能同时参与多笔交易，但是我们可以在同一天重复“买入-卖出-买入-卖出”的神金操作。

   ```c++
   dp[0][0] = 0;
   dp[1][0] = -prices[0];
   dp[2][0] = 0;
   dp[3][0] = -prices[0];
   dp[4][0] = 0;
   ```

   

## 309 买卖股票的最佳时机含冷冻期

显然，这一题是要在`121 买卖股票的最佳时机`上附加一个“冷冻期”概念的判定。在某一天不持有（卖出这股）后，后一天不能买进。第一个想法是，遍历过去，找到收入最高的一天（也就是找到差值最大的两天），这一天的后一天判定为冷冻期。

但是！好像最赚的方法还是多操作几次（有点贪心的意思，见好就收，不贪大钱）。

dbq，是我想太简单了ToT（好的，先去把前面两道炒股困难题啃了ヾ(￣▽￣)）

