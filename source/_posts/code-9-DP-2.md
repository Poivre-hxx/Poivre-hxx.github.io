---
title: 代码随想录一刷笔记_动态规划（下）
tags: 
  - Notes
  - LeetCode
  - Data structure
  - Algorithm
  - C++
categories: 
  - [LeetCode, 代码随想录]
date: 2024-12-09 20:20:00

---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

## 198 打家劫舍

因为之前做了一周的背包问题，所以现在看到题目的第一反应就是，这是背包😖😖....

实际上这一题并不满足背包的条件，背包需要满足容量是固定的，但是这一题是让我求最大的容量，根据题设，这是一个小于40000的正整数....

## 213 打家劫舍Ⅱ

我的想法，本题和上一题的区别在于数组由线性的变成了环状的，所以我加了一个布尔类型的数组用于判断当前的最大值里有没有包含首位数字，然后最后进行一个判断。但是在`[2,1,2,6,1,8,10,10]`这个样例里面没有通过。

```c++
// 处理代码段
if (nums.size() >= 3) {
    int delta1 = dp[nums.size() - 2] + nums[nums.size() - 1];
    int delta2 = dp[nums.size() - 3] + nums[nums.size() - 1];
    if (jud[nums.size() - 2]) delta1 -= min(nums[0], nums[nums.size() - 1]);
    if (jud[nums.size() - 3]) delta2 -= min(nums[0], nums[nums.size() - 1]);
    dp[nums.size()] = max(delta1, delta2);
}
```

#### 题解

看了题解，我是想把这一部分在一个循环里实现，搞复杂了，实际上只要遍历两次dp数组（分别包含首元素和尾元素），然后取最大值即可。。。。

数组环的三种情况：

1. 情况一：考虑不包含首尾元素
2. 情况二：考虑包含首元素，不包含尾元素
3. 情况三：考虑包含尾元素，不包含首元素

这里的情况一是包含在二和三里的，所以只需要遍历两遍取极大值即可。

PS：网友抚平了我提交10多次没有ac的痛苦，笑死了。

<img src="https://pic-poivre.oss-cn-hangzhou.aliyuncs.com/pics/image-20241210145220476.png" alt="image-20241210145220476" style="width:80%;" />

## 337 打家劫舍Ⅲ

第一个想法是，遍历二叉树成一个用前/中/后序排序的数组，然后根据这个数组进行下一步操作，但是演算了一番，似乎不太行得通。

于是乎，就有了第二个想法，使用层序遍历，遍历二叉树成一个二维向量组呢？好像也不太行，只能解决根节点这一层和第二、三层的关系，后面的对应关系就不好找了。

好像还是得在遍历的过程中完成打劫（bushi）

#### 记忆化递归

可以料到，如果使用递归的话大概率是会在一些样例上超时的，所以得要采取一点剪枝策略。

这里就引入了**记忆化递归**的方法。

使用一个map把计算过的结果保存一下，当重复遍历到一个节点时，可以直接复用结果，避免了重复遍历。

#### dp

卡哥定义这里的dp方法为树形dp（亦称为“树形贪心”），但还是逃不出dp五部曲的分析范围！

1. 确定dp数组以及下标的含义

   这里的dp数组容量为2，表示当前偷 & 不偷。

2. 确定递推公式

   数据存储在二叉树中，所以是要在遍历二叉树的过程中进行动规的！

   对当前节点`root`（dp[0]表示不偷，dp[1]表示偷）：

   - 如果不偷这个节点

     ```c++
     int val1 = max(left[0], left[1]) + max(right[0], right[1]);
     ```

     

   - 如果偷这个节点

     ```c++
     int val2 = root->val + dp[0] + dp[1];
     ```

   显然，在计算`root`节点可以偷到的最大金额时，需要知道`root`的两个孩子节点的情况！故，这里需要采用后序遍历的方法递归二叉树！

3. 递归函数如何初始化

   因为是使用后序遍历，所以只需在遍历到二叉树底部时初始化大小为0，容量为2的数组即可。

4. 确定遍历顺序

   由上述可得，使用后序遍历二叉树的方法！

至此，打家劫舍完结力*★,°*:.☆(￣▽￣)/$:*.°★* 。

## 121 买卖股票的最佳时机

试了下双重循环，超时咯！

#### 贪心

简化成了单重循环，记录遍历到当前下标前的所有数值的最小值，然后进行一个比较。

#### dp

第一时间没想到怎么做👉👈

看了下答案，哦，需要使用二维数组啊。然后dp数组的长度就是买卖股票天数的长度，原谅我看到天数定义小于等于10^5的时候不想往这方面考虑了👉👈👉👈

1. 数组下标及其含义

   `dp[i][0]`表示当天持有股票所得最多现金（是个负数，越大越好）

   `dp[i][1]`表示当天不持有股票所得最多现金（是个正数，越大越好）

2. 确定递推公式

   - 对于持有股票

     ```c++
     dp[i][0] = max(-prices[i], dp[i - 1][0]);
     ```

     

   - 对于不持有股票

     ```c++
     dp[i][i] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
     ```

3. 如何初始化

   其他都初始化为0，但是我们需要单独考虑一下第一天的情况（因为第一天没有前一天，比较特殊）。

