---
title: 代码随想录一刷笔记_动态规划（上）
tags: 
  - Notes
  - LeetCode
  - Data structure
  - Algorithm
  - C++
categories: 
  - [LeetCode, 代码随想录]
date: 2024-11-28 20:20:00

---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

## 动态规划理论基础

#### DP的特点

每一个状态是由上一个状态推导出来的（区别于贪心，贪心是局部选择最优）

#### DP的解题步骤

1. **确定dp数组（dp table）以及下标的含义**（很关键⭐⭐⭐⭐⭐）

   这一步，应该是最先得到的，最明显的，就是当下标为 i 的时候题目求得值是多少！然后，再思考一下**怎样递推**（这个难推敲）实现。

2. 确定递推公式（需要推导一下）

3. dp数组如何初始化

4. 确定遍历顺序

5. 举例推导dp数组

## 509 斐波那契数

#### 递归

先是使用了一下递归

时间和空间复杂度还都挺高的

<img src="https://pic-poivre.oss-cn-hangzhou.aliyuncs.com/pics/image-20241128151833407.png" alt="image-20241128151833407" style="width:50%;" />

#### dp

按照dp的解题步骤顺一下这道题

1. 确定dp数组（dp table）以及下标的含义

   dp[i]表示第i个数值

2. 确定递推公式

   dp[i] = dp[i - 1] + dp[i - 2];

3. dp数组如何初始化

   dp[0] = 0, dp[1] = 1;

4. 确定遍历顺序

   从前往后遍历

5. 举例推导dp数组

   举个栗子：0, 1, 1, 2, 3, ...

## 70 爬楼梯

#### 回溯

试了下回溯，这简单题也要插几个超时例子是吧(╯▔皿▔)╯

#### dp

按照dp的解题步骤顺一下这道题

1. **确定dp数组（dp table）以及下标的含义**（确定这个很重要！）

   dp[i]表示到达第i层楼梯有几种方法

2. 确定递推公式（需要演算一下）

   dp[i] = dp[i - 1] + d[i - 2]；

3. dp数组如何初始化

   dp[0] = 1（照顾一下i = 2的情况），dp[1] = 1, dp[2] = 2;

4. 确定遍历顺序

   从前往后遍历

5. 举例推导dp数组

   举个栗子：1, 1, 2, 3, 4, ...

## 746 使用最小花费爬楼梯

#### 回溯

太棒了，又超时了┗|｀O′|┛

#### dp

按照dp的解题步骤顺一下这道题

1. **确定dp数组（dp table）以及下标的含义**（确定这个很重要！）

   dp[i]想从这个台阶出发的低消（最低消费）

2. 确定递推公式（需要演算一下）

   dp[i] = cost[i] + min(dp[i - 1], dp[i - 2])；

3. dp数组如何初始化

   dp[0] = cost[0], dp[1] = cost[1]

4. 确定遍历顺序

   从前往后遍历

5. 举例推导dp数组

   举个栗子：cost为[10, 15, 20]

   则对应的dp数组为[10, 15, 30]

## 62 不同路径

#### dp

按照dp的解题步骤顺一下这道题

1. **确定dp数组（dp table）以及下标的含义**

   dp[i]\[j]到达这个格子的方法有几种

2. 确定递推公式（需要演算一下）

   dp[i]\[j] = dp[i - 1]\[j] + dp[i]\[j - 1]；

3. dp数组如何初始化

   dp[0]\[0] = 0;

4. 确定遍历顺序

   从左到右，从上到下遍历

5. 举例推导dp数组

   举个栗子：dp[0]\[1] = 1; dp[1]\[0] = 1;


#### tips: 如何声明二维的向量

```c++
vector<vector<int>> path(m, vector<int>(n, 0));
```

## 63 不同路径Ⅱ

与`62 不同路径`相比，只要判断先进行对当前位置是否为障碍物的判断就行了，如果是障碍物就continue。

题解的方法有一点冗余力哈哈。

## 343 整数拆分

这一题没有想到，看了一下题解。

第一个想法是，要想使拆分的数乘积最大，最好是拆分的几个数字数值上是近似的（从给出的样例中找的规律），然后拆成几个数字的话我认为可能和对数有关系，不过在样例中遇到了反例（11）。

#### dp

按照dp的解题步骤顺一下这道题

1. **确定dp数组（dp table）以及下标的含义**

   dp[i]表示在下标为i时候的拆分的最大值。

2. 确定递推公式（需要演算一下）

   遍历 j ( 0 < j < table.size())

   - 当拆分为两个数的时候，最大值为：j * (i - j)；

   - 当拆分大于两个数的时候，最大值为：j * dp[i - j]；

     当然，这里的dp[i - j]是由前面遍历过来的，表示的是数值为（i - j）时候的最大值，至少由两个数组成，也就说，这时候起码被拆成了3个数（符合前提，逻辑自证，出院！）

   故，递推公式可以表示为：

   ```c++
   for (int i = 2; i < table.size(); i++) {
       for (int j = 1; j < i; j++) {
           // 这里比较最大值还比较了dp[i]是因为在遍历过程中将最大值存储在了dp[i]里
           dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]);
       }
   }
   ```

   

3. dp数组如何初始化

   dp数组初始化为0。

4. 确定遍历顺序

   从前往后遍历。

5. 举例推导dp数组

   此处省略n字（真的不是杠啊什么的，真的懒了....）

#### 贪心

这个方法正常来说确实是想不到😭😭，需要数学证明（每次拆成n个3，如果剩下是4，则保留4，然后相乘，**但是这个结论需要数学证明其合理性！**）。

## 96 不同的二叉搜索树

（第一反应又当成找不同的二叉排序树了，瞧我这记性）....

#### dp

按照dp的解题步骤顺一下这道题

1. **确定dp数组（dp table）以及下标的含义**

   表示当有 i 个节点时有 dp[i] 个不同的bst树

2. 确定递推公式（需要演算一下）

   如果不考虑头节点的话，那就还剩 i - 1 个节点。

   此时，左子树有 j 个节点，右子树有 k 个节点，满足 j + k = i - 1；遍历一遍，求得所有的可能。

   ```c++
   for (int i = 2; i < dp.size(); i++) {
       for (int j = 0; j < i; j++) {
           dp[i] += dp[j] * dp[i - j - 1];
       }
   }
   ```

   

3. dp数组如何初始化

   dp[0] = 1; dp[1] = 1。

4. 确定遍历顺序

   从小到大遍历

## 背包问题

背包问题的分类

<img src="https://pic-poivre.oss-cn-hangzhou.aliyuncs.com/pics/20210117171307407.png" alt="416.分割等和子集1" style="width:90%;" />

#### 01背包理论基础

问题描述：有 n 件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

#### 使用二维数组DP

按照dp的解题步骤考虑背包问题

1. **确定dp数组（dp table）以及下标的含义**

   这里需要使用二维数组（两个维度分别表示物品和背包容量）

2. 确定递推公式（需要演算一下）

   当遍历dp[i]\[j]的位置时，

   第一步，需要判定物体的大小与j的关系；如果可以放入，需要比较放入后的总价值（放入这个物体可能需要将前面的一些给取出）和放入前的总价值，取较高者。

3. dp数组如何初始化

   思考一些递推公式中可能会产生越界问题的位置：也就是第一行和第一列。

4. 确定遍历顺序

   从左到右，从上到下。

#### 使用滚动数组（一维数组）DP

也就是使用一维数组，将二维数组进行压缩。

1. **确定dp数组（dp table）以及下标的含义**

   使用一维数组。

2. 确定递推公式（需要演算一下）

   当遍历dp[i]\[j]的位置时，

   第一步，需要判定物体的大小与j的关系；如果可以放入，需要比较放入后的总价值（放入这个物体可能需要将前面的一些给取出）和放入前的总价值，取较高者。

3. dp数组如何初始化

   初始化为0即可。

4. 确定遍历顺序

   由于是将二维数组降维成了一维数组，故数据是会覆盖的，所以考虑从大到小遍历。
