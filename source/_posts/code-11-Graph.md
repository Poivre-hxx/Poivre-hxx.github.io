---
title: 代码随想录一刷笔记_图论
tags: 
  - Notes
  - LeetCode
  - Data structure
  - Algorithm
  - C++
categories: 
  - [LeetCode, 代码随想录]
date: 2025-02-08 20:20:00

---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

## 图论理论基础

#### DFS & BFS

- 广度优先适用于解决寻找两个点之间的最短路径问题（不管是否有障碍，**第一条到达终点的路径一定是最短路径！**）
  - 关于BFS存储元素的容器的选择
    - 用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针
    - **用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历**！！

## 797 所有可能的路径

#### dfs

使用回溯方法递归。

## 200 岛屿数量

首先呢，岛屿只能通过四个方向连接起来，也就是“上”、“下”、“左”、“右”。

#### dfs

因为是深搜，所以得先朝一个方向搜索到底，碰壁后再换个方向搜索。

这一题除了存储岛屿的数组以外，还定义了一个数组用于存储是否已经遍历过该岛屿，需要通过深搜得到的新岛屿是否与原岛屿连接并且没有被遍历过两个条件进行判断。

#### bfs

使用广度优先，就需要按照层次遍历当前岛屿周围的岛，那么，就需要一个容器来存储周围层次的岛屿了。

另外，为了避免重复遍历岛屿，当岛屿加入队列时，就需要进行标记；这样一来就不会出现重复入队的情况。

## 105 岛屿的最大面积

这一题就是105的变式，稍微修改一下即可。

## 11 建造最大岛屿

#### 暴力解法

遍历一遍空岛屿，每次都查询一下最大的岛屿面积。

时间复杂度为 O(n4)

#### 改进一下的方法（仔细想了以下似乎行不通）

1. 找到当前最大的岛屿
2. 遍历这个岛屿周围的一圈空岛屿，记录最大岛屿的情况

如果这个大岛屿是个孤岛的话就麻烦了x

#### 较优解

1. 还是遍历一遍岛屿，将相连的岛屿进行标记，并记录下这个标记对应的岛屿面积

   例如，统一标记为一个数值。

2. 遍历海域，计算`当前海域相邻的岛屿面积 + 1 `的值，取最大值。

时间复杂度为 O(n2)。

