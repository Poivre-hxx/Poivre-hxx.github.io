---
​---
title: 代码随想录一刷笔记_链表
tags: 
  - Notes
  - leet code
  - data structure
categories: 
  - [代码随想录]
date: 2024-08-06 20:00:00

​---
---

60+在408的算法考察难度和深度上还是收手了👍）

<!-- more -->

#### 链表基础

###### 什么时候使用数组，什么时候考虑使用链表呢？

首先，链表是随机存储的，数组是连续存储的。

对于数组来说，在有随机访问需求时更适合使用。并且，由于只能一次性地申请一片内存空间，所以数组更适用于有固定大小数据的需求。

对于链表来说，在考虑连续访问的需求时更适合使用。并且，链表的长度是不固定的，可以申请新空间也可以删除旧数据，适合不确定数据量的需求。

###### 链表的定义

```c++
// 单链表
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数
};
// 初始化节点
ListNode* head = new ListNode(5);
```

###### 移除链表中的元素（203）

这一道题中所述的链表是一个不含头节点的链表，所以对其进行处理时需要进行分类讨论：

①如果处理的是头节点，那么需要找到第一个不等于val的值的节点，并且将这个节点赋为头节点；

②如果处理的是非头节点，那么只需将这个节点删除即可。

因此，处理这个问题时有两种方法，一种是按部就班对链表按照两种情况进行分类讨论，或者是创建一个虚拟头节点，将两种情归并为一种。

**在处理这道算法题时遇到的语法问题**：new ListNode(x)的定义、取值、赋值问题

```c++
// 初始化一个空节点，没有赋值，指针指向list
ListNode list = new ListNode();

// 初始化一个空节点，初始赋值为0，指针指向list
ListNode list = new ListNode(0);

// 初始化一个空节点，初始值赋为0，并且list的下一个指针指向head，指针指向list
ListNode list = new ListNode(0, head);

// 定义一个空链表
ListNode list = null;
```

###### 设计链表（707）

对于这道题来说，问题不是出在如何对链表进行增删改查上，而是卡在语法上以及隐含的条件上。

隐含的条件：需要考虑用例链表是否为空？指针指向的节点是头节点？尾节点？空节点的情况。

###### 翻转链表（206）

这种类型的题目在cs考研里属于是重点算法题目，所以我对其核心思想印象还是很深刻的（主要是**双指针法**这一个方法）。

在代码随想录中，还讲述了**递归法**的方法。对照着双指针的方法想，每一次传入的就是当前指向的节点以及其前一个节点，当当前指向节点为空指针时，递归结束。
